<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>RollUp Visualizer</title>
  <style>@font-face {
  font-family: "Oswald";
  font-style: normal;
  font-display: swap;
  font-weight: 500;
  src: local("Oswald Medium"), local("Oswald-Medium"), url("data:font/woff2;base64,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") format("woff2"), url("data:font/woff;base64,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") format("woff");
}
html {
  background-color: #f7eedf;
  color: #333;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  width: 100%;
}

body {
  width: 100%;
  padding: 0;
  margin: 0;
}

svg {
  vertical-align: middle;
}

h1 {
  font-family: "Oswald", "HelveticaNeue-CondensedBold", "Arial Narrow", sans-serif;
  font-weight: 500;
  font-size: 70px;
  text-transform: uppercase;
  text-align: center;
}

.chart {
  position: relative;
  margin: 0 auto;
  min-height: 350px;
}

#charts {
  width: 1000px;
  margin: 0 auto;
}

.tooltip {
  position: absolute;
  z-index: 1070;
  display: block;
  margin: 0;
  font-style: normal;
  font-weight: 400;
  line-height: 1.5;
  text-align: left;
  text-align: start;
  text-decoration: none;
  text-shadow: none;
  text-transform: none;
  letter-spacing: normal;
  word-break: normal;
  word-spacing: normal;
  white-space: normal;
  line-break: auto;
  font-size: 0.875rem;
  word-wrap: break-word;
  opacity: 0;
}

rect {
  stroke: white;
}

text {
  font-size: 0.7em;
  fill: white;
}</style>
</head>
<body>
  <h1>RollUp Visualizer</h1>
  <div id="charts"></div>
  <script>window.nodesData = [{"id":"bundle.min.js","root":{"name":"root","children":[{"name":"stories","children":[{"name":"changeTime","children":[{"name":"changeTime.vue?rollup-plugin-vue=script.js","children":[],"size":1585,"originalSize":1565},{"name":"changeTime.vue","children":[],"size":2201,"originalSize":2734}]},{"name":"line-chart","children":[{"name":"line-chart.vue?rollup-plugin-vue=script.js","children":[],"size":4340,"originalSize":4131},{"name":"line-chart.vue","children":[],"size":1051,"originalSize":4342}]},{"name":"index.js","children":[],"size":327,"originalSize":537}]},{"name":"node_modules","children":[{"name":"vue-runtime-helpers","children":[{"name":"dist","children":[{"name":"normalize-component.js","children":[],"size":2481,"originalSize":2535},{"name":"inject-style","children":[{"name":"browser.js","children":[],"size":1786,"originalSize":1841}]}]}]}]}]}}];</script>
  <script>(function () {
  'use strict';

  var xhtml = "http://www.w3.org/1999/xhtml";

  var namespaces = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };

  function namespace(name) {
    var prefix = name += "", i = prefix.indexOf(":");
    if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
    return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
  }

  function creatorInherit(name) {
    return function() {
      var document = this.ownerDocument,
          uri = this.namespaceURI;
      return uri === xhtml && document.documentElement.namespaceURI === xhtml
          ? document.createElement(name)
          : document.createElementNS(uri, name);
    };
  }

  function creatorFixed(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }

  function creator(name) {
    var fullname = namespace(name);
    return (fullname.local
        ? creatorFixed
        : creatorInherit)(fullname);
  }

  function none() {}

  function selector(selector) {
    return selector == null ? none : function() {
      return this.querySelector(selector);
    };
  }

  function selection_select(select) {
    if (typeof select !== "function") select = selector(select);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
        }
      }
    }

    return new Selection(subgroups, this._parents);
  }

  function empty() {
    return [];
  }

  function selectorAll(selector) {
    return selector == null ? empty : function() {
      return this.querySelectorAll(selector);
    };
  }

  function selection_selectAll(select) {
    if (typeof select !== "function") select = selectorAll(select);

    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          subgroups.push(select.call(node, node.__data__, i, group));
          parents.push(node);
        }
      }
    }

    return new Selection(subgroups, parents);
  }

  function matcher(selector) {
    return function() {
      return this.matches(selector);
    };
  }

  function selection_filter(match) {
    if (typeof match !== "function") match = matcher(match);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
          subgroup.push(node);
        }
      }
    }

    return new Selection(subgroups, this._parents);
  }

  function sparse(update) {
    return new Array(update.length);
  }

  function selection_enter() {
    return new Selection(this._enter || this._groups.map(sparse), this._parents);
  }

  function EnterNode(parent, datum) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum;
  }

  EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
    insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
    querySelector: function(selector) { return this._parent.querySelector(selector); },
    querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
  };

  function constant(x) {
    return function() {
      return x;
    };
  }

  var keyPrefix = "$"; // Protect against keys like __proto__.

  function bindIndex(parent, group, enter, update, exit, data) {
    var i = 0,
        node,
        groupLength = group.length,
        dataLength = data.length;

    // Put any non-null nodes that fit into update.
    // Put any null nodes into enter.
    // Put any remaining data into enter.
    for (; i < dataLength; ++i) {
      if (node = group[i]) {
        node.__data__ = data[i];
        update[i] = node;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }

    // Put any non-null nodes that dont fit into exit.
    for (; i < groupLength; ++i) {
      if (node = group[i]) {
        exit[i] = node;
      }
    }
  }

  function bindKey(parent, group, enter, update, exit, data, key) {
    var i,
        node,
        nodeByKeyValue = {},
        groupLength = group.length,
        dataLength = data.length,
        keyValues = new Array(groupLength),
        keyValue;

    // Compute the key for each node.
    // If multiple nodes have the same key, the duplicates are added to exit.
    for (i = 0; i < groupLength; ++i) {
      if (node = group[i]) {
        keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
        if (keyValue in nodeByKeyValue) {
          exit[i] = node;
        } else {
          nodeByKeyValue[keyValue] = node;
        }
      }
    }

    // Compute the key for each datum.
    // If there a node associated with this key, join and add it to update.
    // If there is not (or the key is a duplicate), add it to enter.
    for (i = 0; i < dataLength; ++i) {
      keyValue = keyPrefix + key.call(parent, data[i], i, data);
      if (node = nodeByKeyValue[keyValue]) {
        update[i] = node;
        node.__data__ = data[i];
        nodeByKeyValue[keyValue] = null;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }

    // Add any remaining nodes that were not bound to data to exit.
    for (i = 0; i < groupLength; ++i) {
      if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
        exit[i] = node;
      }
    }
  }

  function selection_data(value, key) {
    if (!value) {
      data = new Array(this.size()), j = -1;
      this.each(function(d) { data[++j] = d; });
      return data;
    }

    var bind = key ? bindKey : bindIndex,
        parents = this._parents,
        groups = this._groups;

    if (typeof value !== "function") value = constant(value);

    for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
      var parent = parents[j],
          group = groups[j],
          groupLength = group.length,
          data = value.call(parent, parent && parent.__data__, j, parents),
          dataLength = data.length,
          enterGroup = enter[j] = new Array(dataLength),
          updateGroup = update[j] = new Array(dataLength),
          exitGroup = exit[j] = new Array(groupLength);

      bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

      // Now connect the enter nodes to their following update node, such that
      // appendChild can insert the materialized enter node before this node,
      // rather than at the end of the parent node.
      for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1) i1 = i0 + 1;
          while (!(next = updateGroup[i1]) && ++i1 < dataLength);
          previous._next = next || null;
        }
      }
    }

    update = new Selection(update, parents);
    update._enter = enter;
    update._exit = exit;
    return update;
  }

  function selection_exit() {
    return new Selection(this._exit || this._groups.map(sparse), this._parents);
  }

  function selection_join(onenter, onupdate, onexit) {
    var enter = this.enter(), update = this, exit = this.exit();
    enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
    if (onupdate != null) update = onupdate(update);
    if (onexit == null) exit.remove(); else onexit(exit);
    return enter && update ? enter.merge(update).order() : update;
  }

  function selection_merge(selection) {

    for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }

    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }

    return new Selection(merges, this._parents);
  }

  function selection_order() {

    for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
      for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
        if (node = group[i]) {
          if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }

    return this;
  }

  function selection_sort(compare) {
    if (!compare) compare = ascending;

    function compareNode(a, b) {
      return a && b ? compare(a.__data__, b.__data__) : !a - !b;
    }

    for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          sortgroup[i] = node;
        }
      }
      sortgroup.sort(compareNode);
    }

    return new Selection(sortgroups, this._parents).order();
  }

  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function selection_call() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }

  function selection_nodes() {
    var nodes = new Array(this.size()), i = -1;
    this.each(function() { nodes[++i] = this; });
    return nodes;
  }

  function selection_node() {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
        var node = group[i];
        if (node) return node;
      }
    }

    return null;
  }

  function selection_size() {
    var size = 0;
    this.each(function() { ++size; });
    return size;
  }

  function selection_empty() {
    return !this.node();
  }

  function selection_each(callback) {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
        if (node = group[i]) callback.call(node, node.__data__, i, group);
      }
    }

    return this;
  }

  function attrRemove(name) {
    return function() {
      this.removeAttribute(name);
    };
  }

  function attrRemoveNS(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }

  function attrConstant(name, value) {
    return function() {
      this.setAttribute(name, value);
    };
  }

  function attrConstantNS(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }

  function attrFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.removeAttribute(name);
      else this.setAttribute(name, v);
    };
  }

  function attrFunctionNS(fullname, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
      else this.setAttributeNS(fullname.space, fullname.local, v);
    };
  }

  function selection_attr(name, value) {
    var fullname = namespace(name);

    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local
          ? node.getAttributeNS(fullname.space, fullname.local)
          : node.getAttribute(fullname);
    }

    return this.each((value == null
        ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
        ? (fullname.local ? attrFunctionNS : attrFunction)
        : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
  }

  function defaultView(node) {
    return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
        || (node.document && node) // node is a Window
        || node.defaultView; // node is a Document
  }

  function styleRemove(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }

  function styleConstant(name, value, priority) {
    return function() {
      this.style.setProperty(name, value, priority);
    };
  }

  function styleFunction(name, value, priority) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) this.style.removeProperty(name);
      else this.style.setProperty(name, v, priority);
    };
  }

  function selection_style(name, value, priority) {
    return arguments.length > 1
        ? this.each((value == null
              ? styleRemove : typeof value === "function"
              ? styleFunction
              : styleConstant)(name, value, priority == null ? "" : priority))
        : styleValue(this.node(), name);
  }

  function styleValue(node, name) {
    return node.style.getPropertyValue(name)
        || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
  }

  function propertyRemove(name) {
    return function() {
      delete this[name];
    };
  }

  function propertyConstant(name, value) {
    return function() {
      this[name] = value;
    };
  }

  function propertyFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) delete this[name];
      else this[name] = v;
    };
  }

  function selection_property(name, value) {
    return arguments.length > 1
        ? this.each((value == null
            ? propertyRemove : typeof value === "function"
            ? propertyFunction
            : propertyConstant)(name, value))
        : this.node()[name];
  }

  function classArray(string) {
    return string.trim().split(/^|\s+/);
  }

  function classList(node) {
    return node.classList || new ClassList(node);
  }

  function ClassList(node) {
    this._node = node;
    this._names = classArray(node.getAttribute("class") || "");
  }

  ClassList.prototype = {
    add: function(name) {
      var i = this._names.indexOf(name);
      if (i < 0) {
        this._names.push(name);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name) {
      var i = this._names.indexOf(name);
      if (i >= 0) {
        this._names.splice(i, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name) {
      return this._names.indexOf(name) >= 0;
    }
  };

  function classedAdd(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n) list.add(names[i]);
  }

  function classedRemove(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n) list.remove(names[i]);
  }

  function classedTrue(names) {
    return function() {
      classedAdd(this, names);
    };
  }

  function classedFalse(names) {
    return function() {
      classedRemove(this, names);
    };
  }

  function classedFunction(names, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
  }

  function selection_classed(name, value) {
    var names = classArray(name + "");

    if (arguments.length < 2) {
      var list = classList(this.node()), i = -1, n = names.length;
      while (++i < n) if (!list.contains(names[i])) return false;
      return true;
    }

    return this.each((typeof value === "function"
        ? classedFunction : value
        ? classedTrue
        : classedFalse)(names, value));
  }

  function textRemove() {
    this.textContent = "";
  }

  function textConstant(value) {
    return function() {
      this.textContent = value;
    };
  }

  function textFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    };
  }

  function selection_text(value) {
    return arguments.length
        ? this.each(value == null
            ? textRemove : (typeof value === "function"
            ? textFunction
            : textConstant)(value))
        : this.node().textContent;
  }

  function htmlRemove() {
    this.innerHTML = "";
  }

  function htmlConstant(value) {
    return function() {
      this.innerHTML = value;
    };
  }

  function htmlFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    };
  }

  function selection_html(value) {
    return arguments.length
        ? this.each(value == null
            ? htmlRemove : (typeof value === "function"
            ? htmlFunction
            : htmlConstant)(value))
        : this.node().innerHTML;
  }

  function raise() {
    if (this.nextSibling) this.parentNode.appendChild(this);
  }

  function selection_raise() {
    return this.each(raise);
  }

  function lower() {
    if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }

  function selection_lower() {
    return this.each(lower);
  }

  function selection_append(name) {
    var create = typeof name === "function" ? name : creator(name);
    return this.select(function() {
      return this.appendChild(create.apply(this, arguments));
    });
  }

  function constantNull() {
    return null;
  }

  function selection_insert(name, before) {
    var create = typeof name === "function" ? name : creator(name),
        select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
    return this.select(function() {
      return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
    });
  }

  function remove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }

  function selection_remove() {
    return this.each(remove);
  }

  function selection_cloneShallow() {
    return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
  }

  function selection_cloneDeep() {
    return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
  }

  function selection_clone(deep) {
    return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
  }

  function selection_datum(value) {
    return arguments.length
        ? this.property("__data__", value)
        : this.node().__data__;
  }

  var filterEvents = {};

  var event = null;

  if (typeof document !== "undefined") {
    var element = document.documentElement;
    if (!("onmouseenter" in element)) {
      filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
    }
  }

  function filterContextListener(listener, index, group) {
    listener = contextListener(listener, index, group);
    return function(event) {
      var related = event.relatedTarget;
      if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
        listener.call(this, event);
      }
    };
  }

  function contextListener(listener, index, group) {
    return function(event1) {
      var event0 = event; // Events can be reentrant (e.g., focus).
      event = event1;
      try {
        listener.call(this, this.__data__, index, group);
      } finally {
        event = event0;
      }
    };
  }

  function parseTypenames(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
      return {type: t, name: name};
    });
  }

  function onRemove(typename) {
    return function() {
      var on = this.__on;
      if (!on) return;
      for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
        if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
        } else {
          on[++i] = o;
        }
      }
      if (++i) on.length = i;
      else delete this.__on;
    };
  }

  function onAdd(typename, value, capture) {
    var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
    return function(d, i, group) {
      var on = this.__on, o, listener = wrap(value, i, group);
      if (on) for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
          this.addEventListener(o.type, o.listener = listener, o.capture = capture);
          o.value = value;
          return;
        }
      }
      this.addEventListener(typename.type, listener, capture);
      o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
      if (!on) this.__on = [o];
      else on.push(o);
    };
  }

  function selection_on(typename, value, capture) {
    var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
      return;
    }

    on = value ? onAdd : onRemove;
    if (capture == null) capture = false;
    for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
    return this;
  }

  function dispatchEvent(node, type, params) {
    var window = defaultView(node),
        event = window.CustomEvent;

    if (typeof event === "function") {
      event = new event(type, params);
    } else {
      event = window.document.createEvent("Event");
      if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
      else event.initEvent(type, false, false);
    }

    node.dispatchEvent(event);
  }

  function dispatchConstant(type, params) {
    return function() {
      return dispatchEvent(this, type, params);
    };
  }

  function dispatchFunction(type, params) {
    return function() {
      return dispatchEvent(this, type, params.apply(this, arguments));
    };
  }

  function selection_dispatch(type, params) {
    return this.each((typeof params === "function"
        ? dispatchFunction
        : dispatchConstant)(type, params));
  }

  var root = [null];

  function Selection(groups, parents) {
    this._groups = groups;
    this._parents = parents;
  }

  function selection() {
    return new Selection([[document.documentElement]], root);
  }

  Selection.prototype = selection.prototype = {
    constructor: Selection,
    select: selection_select,
    selectAll: selection_selectAll,
    filter: selection_filter,
    data: selection_data,
    enter: selection_enter,
    exit: selection_exit,
    join: selection_join,
    merge: selection_merge,
    order: selection_order,
    sort: selection_sort,
    call: selection_call,
    nodes: selection_nodes,
    node: selection_node,
    size: selection_size,
    empty: selection_empty,
    each: selection_each,
    attr: selection_attr,
    style: selection_style,
    property: selection_property,
    classed: selection_classed,
    text: selection_text,
    html: selection_html,
    raise: selection_raise,
    lower: selection_lower,
    append: selection_append,
    insert: selection_insert,
    remove: selection_remove,
    clone: selection_clone,
    datum: selection_datum,
    on: selection_on,
    dispatch: selection_dispatch
  };

  function select(selector) {
    return typeof selector === "string"
        ? new Selection([[document.querySelector(selector)]], [document.documentElement])
        : new Selection([[selector]], root);
  }

  function sourceEvent() {
    var current = event, source;
    while (source = current.sourceEvent) current = source;
    return current;
  }

  function point(node, event) {
    var svg = node.ownerSVGElement || node;

    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }

    var rect = node.getBoundingClientRect();
    return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
  }

  function d3mouse(node) {
    var event = sourceEvent();
    if (event.changedTouches) event = event.changedTouches[0];
    return point(node, event);
  }

  var prefix = "$";

  function Map() {}

  Map.prototype = map.prototype = {
    constructor: Map,
    has: function(key) {
      return (prefix + key) in this;
    },
    get: function(key) {
      return this[prefix + key];
    },
    set: function(key, value) {
      this[prefix + key] = value;
      return this;
    },
    remove: function(key) {
      var property = prefix + key;
      return property in this && delete this[property];
    },
    clear: function() {
      for (var property in this) if (property[0] === prefix) delete this[property];
    },
    keys: function() {
      var keys = [];
      for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
      return keys;
    },
    values: function() {
      var values = [];
      for (var property in this) if (property[0] === prefix) values.push(this[property]);
      return values;
    },
    entries: function() {
      var entries = [];
      for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
      return entries;
    },
    size: function() {
      var size = 0;
      for (var property in this) if (property[0] === prefix) ++size;
      return size;
    },
    empty: function() {
      for (var property in this) if (property[0] === prefix) return false;
      return true;
    },
    each: function(f) {
      for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
    }
  };

  function map(object, f) {
    var map = new Map;

    // Copy constructor.
    if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

    // Index array by numeric index or specified key function.
    else if (Array.isArray(object)) {
      var i = -1,
          n = object.length,
          o;

      if (f == null) while (++i < n) map.set(i, object[i]);
      else while (++i < n) map.set(f(o = object[i], i, object), o);
    }

    // Convert object to map.
    else if (object) for (var key in object) map.set(key, object[key]);

    return map;
  }

  function d3nest() {
    var keys = [],
        sortKeys = [],
        sortValues,
        rollup,
        nest;

    function apply(array, depth, createResult, setResult) {
      if (depth >= keys.length) {
        if (sortValues != null) array.sort(sortValues);
        return rollup != null ? rollup(array) : array;
      }

      var i = -1,
          n = array.length,
          key = keys[depth++],
          keyValue,
          value,
          valuesByKey = map(),
          values,
          result = createResult();

      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
          values.push(value);
        } else {
          valuesByKey.set(keyValue, [value]);
        }
      }

      valuesByKey.each(function(values, key) {
        setResult(result, key, apply(values, depth, createResult, setResult));
      });

      return result;
    }

    function entries(map, depth) {
      if (++depth > keys.length) return map;
      var array, sortKey = sortKeys[depth - 1];
      if (rollup != null && depth >= keys.length) array = map.entries();
      else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
      return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
    }

    return nest = {
      object: function(array) { return apply(array, 0, createObject, setObject); },
      map: function(array) { return apply(array, 0, createMap, setMap); },
      entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
      key: function(d) { keys.push(d); return nest; },
      sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
      sortValues: function(order) { sortValues = order; return nest; },
      rollup: function(f) { rollup = f; return nest; }
    };
  }

  function createObject() {
    return {};
  }

  function setObject(object, key, value) {
    object[key] = value;
  }

  function createMap() {
    return map();
  }

  function setMap(map, key, value) {
    map.set(key, value);
  }

  function Set() {}

  var proto = map.prototype;

  Set.prototype = set.prototype = {
    constructor: Set,
    has: proto.has,
    add: function(value) {
      value += "";
      this[prefix + value] = value;
      return this;
    },
    remove: proto.remove,
    clear: proto.clear,
    values: proto.keys,
    size: proto.size,
    empty: proto.empty,
    each: proto.each
  };

  function set(object, f) {
    var set = new Set;

    // Copy constructor.
    if (object instanceof Set) object.each(function(value) { set.add(value); });

    // Otherwise, assume its an array.
    else if (object) {
      var i = -1, n = object.length;
      if (f == null) while (++i < n) set.add(object[i]);
      else while (++i < n) set.add(f(object[i], i, object));
    }

    return set;
  }

  let count = 0;

  class Id {
    constructor(id) {
      this._id = id;
      this._href = createUrl({ hash: id }).href;
    }

    get id() {
      return this._id;
    }

    get href() {
      return this._href;
    }

    toString() {
      return `url(${this.href})`;
    }
  }

  function uid(name) {
    count += 1;
    const id = ["O", name, count].filter(Boolean).join("-");
    return new Id(id);
  }

  function createUrl(options = {}) {
    const url = new URL(window.location);
    return Object.assign(url, options);
  }

  function getAncestors(node) {
    const parents = [];
    while (node != null) {
      parents.push(node);
      node = node.parent;
    }
    return parents;
  }

  function color(node) {
    if (node.children && node.children.length) {
      const parents = getAncestors(node);
      const hasNodeModules = !!parents.find(n => {
        return n.data.name === "node_modules";
      });
      return hasNodeModules ? "#599e59" : "#487ea4";
    } else {
      return "#db7100";
    }
  }

  function count$1(node) {
    var sum = 0,
        children = node.children,
        i = children && children.length;
    if (!i) sum = 1;
    else while (--i >= 0) sum += children[i].value;
    node.value = sum;
  }

  function node_count() {
    return this.eachAfter(count$1);
  }

  function node_each(callback) {
    var node = this, current, next = [node], children, i, n;
    do {
      current = next.reverse(), next = [];
      while (node = current.pop()) {
        callback(node), children = node.children;
        if (children) for (i = 0, n = children.length; i < n; ++i) {
          next.push(children[i]);
        }
      }
    } while (next.length);
    return this;
  }

  function node_eachBefore(callback) {
    var node = this, nodes = [node], children, i;
    while (node = nodes.pop()) {
      callback(node), children = node.children;
      if (children) for (i = children.length - 1; i >= 0; --i) {
        nodes.push(children[i]);
      }
    }
    return this;
  }

  function node_eachAfter(callback) {
    var node = this, nodes = [node], next = [], children, i, n;
    while (node = nodes.pop()) {
      next.push(node), children = node.children;
      if (children) for (i = 0, n = children.length; i < n; ++i) {
        nodes.push(children[i]);
      }
    }
    while (node = next.pop()) {
      callback(node);
    }
    return this;
  }

  function node_sum(value) {
    return this.eachAfter(function(node) {
      var sum = +value(node.data) || 0,
          children = node.children,
          i = children && children.length;
      while (--i >= 0) sum += children[i].value;
      node.value = sum;
    });
  }

  function node_sort(compare) {
    return this.eachBefore(function(node) {
      if (node.children) {
        node.children.sort(compare);
      }
    });
  }

  function node_path(end) {
    var start = this,
        ancestor = leastCommonAncestor(start, end),
        nodes = [start];
    while (start !== ancestor) {
      start = start.parent;
      nodes.push(start);
    }
    var k = nodes.length;
    while (end !== ancestor) {
      nodes.splice(k, 0, end);
      end = end.parent;
    }
    return nodes;
  }

  function leastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = a.ancestors(),
        bNodes = b.ancestors(),
        c = null;
    a = aNodes.pop();
    b = bNodes.pop();
    while (a === b) {
      c = a;
      a = aNodes.pop();
      b = bNodes.pop();
    }
    return c;
  }

  function node_ancestors() {
    var node = this, nodes = [node];
    while (node = node.parent) {
      nodes.push(node);
    }
    return nodes;
  }

  function node_descendants() {
    var nodes = [];
    this.each(function(node) {
      nodes.push(node);
    });
    return nodes;
  }

  function node_leaves() {
    var leaves = [];
    this.eachBefore(function(node) {
      if (!node.children) {
        leaves.push(node);
      }
    });
    return leaves;
  }

  function node_links() {
    var root = this, links = [];
    root.each(function(node) {
      if (node !== root) { // Dont include the roots parent, if any.
        links.push({source: node.parent, target: node});
      }
    });
    return links;
  }

  function hierarchy(data, children) {
    var root = new Node(data),
        valued = +data.value && (root.value = data.value),
        node,
        nodes = [root],
        child,
        childs,
        i,
        n;

    if (children == null) children = defaultChildren;

    while (node = nodes.pop()) {
      if (valued) node.value = +node.data.value;
      if ((childs = children(node.data)) && (n = childs.length)) {
        node.children = new Array(n);
        for (i = n - 1; i >= 0; --i) {
          nodes.push(child = node.children[i] = new Node(childs[i]));
          child.parent = node;
          child.depth = node.depth + 1;
        }
      }
    }

    return root.eachBefore(computeHeight);
  }

  function node_copy() {
    return hierarchy(this).eachBefore(copyData);
  }

  function defaultChildren(d) {
    return d.children;
  }

  function copyData(node) {
    node.data = node.data.data;
  }

  function computeHeight(node) {
    var height = 0;
    do node.height = height;
    while ((node = node.parent) && (node.height < ++height));
  }

  function Node(data) {
    this.data = data;
    this.depth =
    this.height = 0;
    this.parent = null;
  }

  Node.prototype = hierarchy.prototype = {
    constructor: Node,
    count: node_count,
    each: node_each,
    eachAfter: node_eachAfter,
    eachBefore: node_eachBefore,
    sum: node_sum,
    sort: node_sort,
    path: node_path,
    ancestors: node_ancestors,
    descendants: node_descendants,
    leaves: node_leaves,
    links: node_links,
    copy: node_copy
  };

  function required(f) {
    if (typeof f !== "function") throw new Error;
    return f;
  }

  function constantZero() {
    return 0;
  }

  function constant$1(x) {
    return function() {
      return x;
    };
  }

  function roundNode(node) {
    node.x0 = Math.round(node.x0);
    node.y0 = Math.round(node.y0);
    node.x1 = Math.round(node.x1);
    node.y1 = Math.round(node.y1);
  }

  function treemapDice(parent, x0, y0, x1, y1) {
    var nodes = parent.children,
        node,
        i = -1,
        n = nodes.length,
        k = parent.value && (x1 - x0) / parent.value;

    while (++i < n) {
      node = nodes[i], node.y0 = y0, node.y1 = y1;
      node.x0 = x0, node.x1 = x0 += node.value * k;
    }
  }

  function treemapSlice(parent, x0, y0, x1, y1) {
    var nodes = parent.children,
        node,
        i = -1,
        n = nodes.length,
        k = parent.value && (y1 - y0) / parent.value;

    while (++i < n) {
      node = nodes[i], node.x0 = x0, node.x1 = x1;
      node.y0 = y0, node.y1 = y0 += node.value * k;
    }
  }

  var phi = (1 + Math.sqrt(5)) / 2;

  function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
    var rows = [],
        nodes = parent.children,
        row,
        nodeValue,
        i0 = 0,
        i1 = 0,
        n = nodes.length,
        dx, dy,
        value = parent.value,
        sumValue,
        minValue,
        maxValue,
        newRatio,
        minRatio,
        alpha,
        beta;

    while (i0 < n) {
      dx = x1 - x0, dy = y1 - y0;

      // Find the next non-empty node.
      do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
      minValue = maxValue = sumValue;
      alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
      beta = sumValue * sumValue * alpha;
      minRatio = Math.max(maxValue / beta, beta / minValue);

      // Keep adding nodes while the aspect ratio maintains or improves.
      for (; i1 < n; ++i1) {
        sumValue += nodeValue = nodes[i1].value;
        if (nodeValue < minValue) minValue = nodeValue;
        if (nodeValue > maxValue) maxValue = nodeValue;
        beta = sumValue * sumValue * alpha;
        newRatio = Math.max(maxValue / beta, beta / minValue);
        if (newRatio > minRatio) { sumValue -= nodeValue; break; }
        minRatio = newRatio;
      }

      // Position and record the row orientation.
      rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
      if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
      else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
      value -= sumValue, i0 = i1;
    }

    return rows;
  }

  var squarify = (function custom(ratio) {

    function squarify(parent, x0, y0, x1, y1) {
      squarifyRatio(ratio, parent, x0, y0, x1, y1);
    }

    squarify.ratio = function(x) {
      return custom((x = +x) > 1 ? x : 1);
    };

    return squarify;
  })(phi);

  function d3treemap() {
    var tile = squarify,
        round = false,
        dx = 1,
        dy = 1,
        paddingStack = [0],
        paddingInner = constantZero,
        paddingTop = constantZero,
        paddingRight = constantZero,
        paddingBottom = constantZero,
        paddingLeft = constantZero;

    function treemap(root) {
      root.x0 =
      root.y0 = 0;
      root.x1 = dx;
      root.y1 = dy;
      root.eachBefore(positionNode);
      paddingStack = [0];
      if (round) root.eachBefore(roundNode);
      return root;
    }

    function positionNode(node) {
      var p = paddingStack[node.depth],
          x0 = node.x0 + p,
          y0 = node.y0 + p,
          x1 = node.x1 - p,
          y1 = node.y1 - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
      if (node.children) {
        p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
        x0 += paddingLeft(node) - p;
        y0 += paddingTop(node) - p;
        x1 -= paddingRight(node) - p;
        y1 -= paddingBottom(node) - p;
        if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
        if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
        tile(node, x0, y0, x1, y1);
      }
    }

    treemap.round = function(x) {
      return arguments.length ? (round = !!x, treemap) : round;
    };

    treemap.size = function(x) {
      return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
    };

    treemap.tile = function(x) {
      return arguments.length ? (tile = required(x), treemap) : tile;
    };

    treemap.padding = function(x) {
      return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
    };

    treemap.paddingInner = function(x) {
      return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$1(+x), treemap) : paddingInner;
    };

    treemap.paddingOuter = function(x) {
      return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
    };

    treemap.paddingTop = function(x) {
      return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$1(+x), treemap) : paddingTop;
    };

    treemap.paddingRight = function(x) {
      return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$1(+x), treemap) : paddingRight;
    };

    treemap.paddingBottom = function(x) {
      return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$1(+x), treemap) : paddingBottom;
    };

    treemap.paddingLeft = function(x) {
      return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$1(+x), treemap) : paddingLeft;
    };

    return treemap;
  }

  /*!
   * bytes
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015 Jed Watson
   * MIT Licensed
   */
  var format_1 = format;

  /**
   * Module variables.
   * @private
   */

  var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;

  var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;

  var map$1 = {
    b:  1,
    kb: 1 << 10,
    mb: 1 << 20,
    gb: 1 << 30,
    tb: Math.pow(1024, 4),
    pb: Math.pow(1024, 5),
  };

  /**
   * Format the given value in bytes into a string.
   *
   * If the value is negative, it is kept as such. If it is a float,
   * it is rounded.
   *
   * @param {number} value
   * @param {object} [options]
   * @param {number} [options.decimalPlaces=2]
   * @param {number} [options.fixedDecimals=false]
   * @param {string} [options.thousandsSeparator=]
   * @param {string} [options.unit=]
   * @param {string} [options.unitSeparator=]
   *
   * @returns {string|null}
   * @public
   */

  function format(value, options) {
    if (!Number.isFinite(value)) {
      return null;
    }

    var mag = Math.abs(value);
    var thousandsSeparator = (options && options.thousandsSeparator) || '';
    var unitSeparator = (options && options.unitSeparator) || '';
    var decimalPlaces = (options && options.decimalPlaces !== undefined) ? options.decimalPlaces : 2;
    var fixedDecimals = Boolean(options && options.fixedDecimals);
    var unit = (options && options.unit) || '';

    if (!unit || !map$1[unit.toLowerCase()]) {
      if (mag >= map$1.pb) {
        unit = 'PB';
      } else if (mag >= map$1.tb) {
        unit = 'TB';
      } else if (mag >= map$1.gb) {
        unit = 'GB';
      } else if (mag >= map$1.mb) {
        unit = 'MB';
      } else if (mag >= map$1.kb) {
        unit = 'KB';
      } else {
        unit = 'B';
      }
    }

    var val = value / map$1[unit.toLowerCase()];
    var str = val.toFixed(decimalPlaces);

    if (!fixedDecimals) {
      str = str.replace(formatDecimalsRegExp, '$1');
    }

    if (thousandsSeparator) {
      str = str.replace(formatThousandsRegExp, thousandsSeparator);
    }

    return str + unitSeparator + unit;
  }

  // https://www.d3-graph-gallery.com/graph/interactivity_tooltip.html#template

  const createTooltip = node =>
    node
      .append("div")
      .style("opacity", 0)
      .attr("class", "tooltip")
      .style("background-color", "white")
      .style("border", "solid")
      .style("border-width", "2px")
      .style("border-radius", "5px")
      .style("padding", "5px");

  const createMouseover = tooltipNode => () => tooltipNode.style("opacity", 1);

  const createMousemove = (tooltipNode, container, totalSize) => d => {
    const [x, y] = d3mouse(container);
    const nodePath = d
      .ancestors()
      .reverse()
      .map(d => d.data.name)
      .join("/");

    const percentageNum = (100 * d.value) / totalSize;
    const percentage = percentageNum.toFixed(2);
    const percentageString = percentage + "%";

    const str = `${nodePath}<br/><b>${format_1(d.value || d.size)}</b><br/>${percentageString}`;

    tooltipNode
      .html(str)
      .style("left", x + 30 + "px")
      .style("top", y + "px");
  };

  const createMouseleave = tooltipNode => () => tooltipNode.style("opacity", 0);

  const WIDTH = 1000;
  const HEIGHT = 700;

  const chartsContainer = document.querySelector("#charts");

  const format$1 = format_1;

  for (const { id, root: data } of window.nodesData) {
    const wrapper = document.createElement("div");
    wrapper.innerHTML = `
      <div class="chart">
        <h3>${id}</h3>
      </div>
      `;
    const chartNode = wrapper.querySelector(".chart");
    chartsContainer.appendChild(chartNode);

    const treemapLayout = d3treemap()
      .size([WIDTH, HEIGHT])
      .paddingOuter(8)
      .paddingTop(20)
      .paddingInner(5)
      .round(true);

    const tooltip = createTooltip(select(chartNode));

    const root = hierarchy(data)
      .sum(d => {
        if (d.children && d.children.length) {
          return 0;
        } else {
          return d.size;
        }
      })
      .sort();

    const totalSize = root.value;

    treemapLayout(root);

    const svg = select(chartNode)
      .append("svg")
      .attr("viewBox", [0, 0, WIDTH, HEIGHT]);

    const shadow = uid("shadow");

    svg
      .append("filter")
      .attr("id", shadow.id)
      .append("feDropShadow")
      .attr("flood-opacity", 0.3)
      .attr("dx", 0)
      .attr("stdDeviation", 3);

    const node = svg
      .selectAll("g")
      .data(
        d3nest()
          .key(d => d.height)
          .entries(root.descendants())
      )
      .join("g")
      .attr("filter", shadow)
      .selectAll("g")
      .data(d => d.values)
      .join("g")
      .attr("transform", d => `translate(${d.x0},${d.y0})`)
      .on("mouseover", createMouseover(tooltip))
      .on("mousemove", createMousemove(tooltip, chartNode, totalSize))
      .on("mouseleave", createMouseleave(tooltip));

    node
      .append("rect")
      .attr("id", d => (d.nodeUid = uid("node")).id)
      .attr("fill", d => color(d))
      .attr("width", d => d.x1 - d.x0)
      .attr("height", d => d.y1 - d.y0);

    node
      .append("clipPath")
      .attr("id", d => (d.clipUid = uid("clip")).id)
      .append("use")
      .attr("xlink:href", d => d.nodeUid.href);

    node
      .append("text")
      .attr("clip-path", d => d.clipUid)
      .selectAll("tspan")
      .data(d => d.data.name.split(/(?=[A-Z][^A-Z])/g).concat(format$1(d.value)))
      .join("tspan")
      .attr("fill-opacity", (d, i, nodes) => (i === nodes.length - 1 ? 0.7 : null))
      .text(d => d);

    node
      .filter(d => d.children)
      .selectAll("tspan")
      .attr("dx", 3)
      .attr("y", 13);

    node
      .filter(d => !d.children)
      .selectAll("tspan")
      .attr("x", 3)
      .attr("y", (d, i, nodes) => `${(i === nodes.length - 1) * 0.3 + 1.1 + i * 0.9}em`);
  }

}());
</script>
</body>
</html>
